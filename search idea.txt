import CoinNameMap from '../../static_data/coin_id_map.json'
const CoinSymbols = Object.keys(CoinNameMap)
const CoinNames = CoinSymbols.map(s => CoinNameMap[s])

function getMatchLenWord(str, word) {
    let matchLen = 0
    for(let i = 0; i < str.length; i++) {
        // Not a valid match unless starts/ends with either space or start/end of string
        if(str.charAt(i - 1).trim().length === 1)
            continue

        let thisMatchLen = 0        
        for(let j = 0; j < word.length && j + i < str.length; j++) {
            if(word.charAt(j) === str.charAt(j + i))
                thisMatchLen++
            else
                break
        }

        // Not a valid match unless starts/ends with either space or start/end of string
        if(!str.charAt(i + thisMatchLen).trim())
            matchLen = Math.max(matchLen, thisMatchLen)

        if(matchLen === hint.length)
            break
    }
    return matchLen
}

dynamicHints = {
    number: (str) => {
        let args = {
            isHinted: false,
            isDefiniteHinted: false,
            number: 1
        }

        str.split(" ").map(w => w.length > 0).forEach(word => {
            if(!isNaN(word)) {
                args = {
                    ...args,
                    isHinted: true,
                    isGuess: false,
                    number: Number(word)
                }
            }
        })

        return args
    },
    coin: (str) => {
        let coinSuggestions = []

        CoinSymbols.forEach((symbol, i) => {
            const matchLen = getMatchLenWord(str, symbol)
            if(matchLen === symbol.length) {
                coinSuggestions.push({symbol: symbol, isExactMatch: true})
            }
            else if(matchLen > 0) {
                coinSuggestions.push({symbol: symbol, isExactMatch: false})
            }
        })

        CoinNames.forEach((name, i) => {
            const matchLen = getMatchLenWord(str, name.toLowerCase())
            if(matchLen === name.length) {
                coinSuggestions.push({symbol: CoinSymbols[i], isExactMatch: true})
            }
            else if(matchLen > 0) {
                coinSuggestions.push({symbol: CoinSymbols[i], isExactMatch: false})
            }
        })

        // Also need to sort by match closeness + if is in wallets

        args: {
            isHinted: coinSuggestions.length > 0,
            foundExactMatch: coinSuggestions.length >= 1 && coinSuggestions[0].isExactMatch,
            coins: coinSuggestions.map(cs => cs.symbol)
        }
    },
}

function parseHints(hints, definiteHints, str) {
    str = str.toLowerCase()
    let allHints = hints.map(h => {hint: h.toLowerCase(), definite: false}).concat(definiteHints.map(dh => {hint: dh.toLowerCase(), definite: true}))

    let args = {
        isHinted: false,
        isDefiniteHinted: false
    }

    allHints.forEach(({hint, definite}) => {
        // Dynamic hints: {coin}, {number}
        if(hint.startsWith("{")) {
            const hintName = hint.replace("{", "").replace("}", "")
            const dynamicHintResult = dynamicHints[hintName](str)
            args = {
                ...args, ...dynamicHintResult,
                isHinted: args.isHinted || dynamicHintResult.isHinted,
                isDefiniteHinted: args.isHintedDefinite || (definite && dynamicHintResult.isHinted & dynamicHintResult.foundExactMatch)
            }
        }
        // Normal textual hint
        else {
            let matchLen = getMatchLenWord(str, hint)
            
            args = {
                ...args,
                isHinted: args.isHinted || matchLen > 0,
                isDefiniteHinted: args.isHintedDefinite || (matchLen === hint.length && definite)
            }
        }
    })

    return args
}

actions = {
    overview: 
    {
        execute: () => Router.push(`/`),
        getSuggestions: () => ["Overview"],
        definiteHints: ["Overview"]
    },
    analyze: {
        execute: ({coins}) => Router.push(`/analyze/${coins[0]}`),
        getSuggestions: ({coins, number}) => {
            return coins.map(c => {
                return `Analyze ${c}`
            })
        },
        definiteHints: ["Analyze"],
        hints: ["{coin}"]
    },
    addCoin: {
        execute: ({coins, number}) => StoreSingleton.addBalanceSmart(coins[0], number),
        getSuggestions: ({coins, number}) => {
            return coins.map(c => {
                return `${number >= 0 ? "Add" : "Subtract"} ${number} ${c}`
            })
        },
        definiteHints: ["Add", "{number}"],
        hints: ["{coin}"]
    },
    removeCoinFromWallet: {
        execute: ({coins}) => StoreSingleton.removeCoinWallet(coins[0]),
        getSuggestions: ({coins}) => {
            return coins.filter(c => StoreSingleton.walletData.find(w => w.coin === c)).map(c => {
                return `Remove ${c} from portfolio`
            })
        },
        definiteHints: ["Remove"],
        hints: ["{coin}"]
    },
}

function getSuggestions(text, count) {
    const parseHintsResults = actions.map(a => parseHints(a.hints || [], a.definiteHints || [], text))
    const actionArgs = parseHintsResults.filter(p => p.isHinted)
    const candidateActions = actions.filter((_, i) => parseHintsResults[i].isHinted)

    const definiteHintedIdx = actionArgs.findIndex(args => args.isDefiniteHinted)
    if(definiteHintedIdx > -1) {
        actionArgs = [actionArgs[definiteHintedIdx]]
        candidateActions = [candidateActions[definiteHintedIdx]]
    }

    let suggestionsPer = Math.max(1, Math.floor(count / candidateActions.length))
    let suggestions = []

    candidateActions.forEach((action, i) => {
        suggestions = suggestions.concat(action.getSuggestions(actionArgs[i]).slice(0, suggestionsPer))
    })

    return suggestions.slice(0, count)
}